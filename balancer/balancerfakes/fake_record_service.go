// Code generated by counterfeiter. DO NOT EDIT.
package balancerfakes

import (
	"balancer-api/balancer"
	"balancer-api/models"
	"sync"
)

type FakeRecordService struct {
	CreateRecordStub        func(*models.Record) (*uint64, error)
	createRecordMutex       sync.RWMutex
	createRecordArgsForCall []struct {
		arg1 *models.Record
	}
	createRecordReturns struct {
		result1 *uint64
		result2 error
	}
	createRecordReturnsOnCall map[int]struct {
		result1 *uint64
		result2 error
	}
	DeleteRecordStub        func(uint64) error
	deleteRecordMutex       sync.RWMutex
	deleteRecordArgsForCall []struct {
		arg1 uint64
	}
	deleteRecordReturns struct {
		result1 error
	}
	deleteRecordReturnsOnCall map[int]struct {
		result1 error
	}
	GetAllRecordsStub        func() (*[]models.Record, error)
	getAllRecordsMutex       sync.RWMutex
	getAllRecordsArgsForCall []struct {
	}
	getAllRecordsReturns struct {
		result1 *[]models.Record
		result2 error
	}
	getAllRecordsReturnsOnCall map[int]struct {
		result1 *[]models.Record
		result2 error
	}
	GetRecordStub        func(string) (*models.Record, error)
	getRecordMutex       sync.RWMutex
	getRecordArgsForCall []struct {
		arg1 string
	}
	getRecordReturns struct {
		result1 *models.Record
		result2 error
	}
	getRecordReturnsOnCall map[int]struct {
		result1 *models.Record
		result2 error
	}
	GetRecordsByTypeStub        func(string) (*[]models.Record, error)
	getRecordsByTypeMutex       sync.RWMutex
	getRecordsByTypeArgsForCall []struct {
		arg1 string
	}
	getRecordsByTypeReturns struct {
		result1 *[]models.Record
		result2 error
	}
	getRecordsByTypeReturnsOnCall map[int]struct {
		result1 *[]models.Record
		result2 error
	}
	UpdateRecordStub        func(*models.Record) error
	updateRecordMutex       sync.RWMutex
	updateRecordArgsForCall []struct {
		arg1 *models.Record
	}
	updateRecordReturns struct {
		result1 error
	}
	updateRecordReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeRecordService) CreateRecord(arg1 *models.Record) (*uint64, error) {
	fake.createRecordMutex.Lock()
	ret, specificReturn := fake.createRecordReturnsOnCall[len(fake.createRecordArgsForCall)]
	fake.createRecordArgsForCall = append(fake.createRecordArgsForCall, struct {
		arg1 *models.Record
	}{arg1})
	stub := fake.CreateRecordStub
	fakeReturns := fake.createRecordReturns
	fake.recordInvocation("CreateRecord", []interface{}{arg1})
	fake.createRecordMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRecordService) CreateRecordCallCount() int {
	fake.createRecordMutex.RLock()
	defer fake.createRecordMutex.RUnlock()
	return len(fake.createRecordArgsForCall)
}

func (fake *FakeRecordService) CreateRecordCalls(stub func(*models.Record) (*uint64, error)) {
	fake.createRecordMutex.Lock()
	defer fake.createRecordMutex.Unlock()
	fake.CreateRecordStub = stub
}

func (fake *FakeRecordService) CreateRecordArgsForCall(i int) *models.Record {
	fake.createRecordMutex.RLock()
	defer fake.createRecordMutex.RUnlock()
	argsForCall := fake.createRecordArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRecordService) CreateRecordReturns(result1 *uint64, result2 error) {
	fake.createRecordMutex.Lock()
	defer fake.createRecordMutex.Unlock()
	fake.CreateRecordStub = nil
	fake.createRecordReturns = struct {
		result1 *uint64
		result2 error
	}{result1, result2}
}

func (fake *FakeRecordService) CreateRecordReturnsOnCall(i int, result1 *uint64, result2 error) {
	fake.createRecordMutex.Lock()
	defer fake.createRecordMutex.Unlock()
	fake.CreateRecordStub = nil
	if fake.createRecordReturnsOnCall == nil {
		fake.createRecordReturnsOnCall = make(map[int]struct {
			result1 *uint64
			result2 error
		})
	}
	fake.createRecordReturnsOnCall[i] = struct {
		result1 *uint64
		result2 error
	}{result1, result2}
}

func (fake *FakeRecordService) DeleteRecord(arg1 uint64) error {
	fake.deleteRecordMutex.Lock()
	ret, specificReturn := fake.deleteRecordReturnsOnCall[len(fake.deleteRecordArgsForCall)]
	fake.deleteRecordArgsForCall = append(fake.deleteRecordArgsForCall, struct {
		arg1 uint64
	}{arg1})
	stub := fake.DeleteRecordStub
	fakeReturns := fake.deleteRecordReturns
	fake.recordInvocation("DeleteRecord", []interface{}{arg1})
	fake.deleteRecordMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeRecordService) DeleteRecordCallCount() int {
	fake.deleteRecordMutex.RLock()
	defer fake.deleteRecordMutex.RUnlock()
	return len(fake.deleteRecordArgsForCall)
}

func (fake *FakeRecordService) DeleteRecordCalls(stub func(uint64) error) {
	fake.deleteRecordMutex.Lock()
	defer fake.deleteRecordMutex.Unlock()
	fake.DeleteRecordStub = stub
}

func (fake *FakeRecordService) DeleteRecordArgsForCall(i int) uint64 {
	fake.deleteRecordMutex.RLock()
	defer fake.deleteRecordMutex.RUnlock()
	argsForCall := fake.deleteRecordArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRecordService) DeleteRecordReturns(result1 error) {
	fake.deleteRecordMutex.Lock()
	defer fake.deleteRecordMutex.Unlock()
	fake.DeleteRecordStub = nil
	fake.deleteRecordReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRecordService) DeleteRecordReturnsOnCall(i int, result1 error) {
	fake.deleteRecordMutex.Lock()
	defer fake.deleteRecordMutex.Unlock()
	fake.DeleteRecordStub = nil
	if fake.deleteRecordReturnsOnCall == nil {
		fake.deleteRecordReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteRecordReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRecordService) GetAllRecords() (*[]models.Record, error) {
	fake.getAllRecordsMutex.Lock()
	ret, specificReturn := fake.getAllRecordsReturnsOnCall[len(fake.getAllRecordsArgsForCall)]
	fake.getAllRecordsArgsForCall = append(fake.getAllRecordsArgsForCall, struct {
	}{})
	stub := fake.GetAllRecordsStub
	fakeReturns := fake.getAllRecordsReturns
	fake.recordInvocation("GetAllRecords", []interface{}{})
	fake.getAllRecordsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRecordService) GetAllRecordsCallCount() int {
	fake.getAllRecordsMutex.RLock()
	defer fake.getAllRecordsMutex.RUnlock()
	return len(fake.getAllRecordsArgsForCall)
}

func (fake *FakeRecordService) GetAllRecordsCalls(stub func() (*[]models.Record, error)) {
	fake.getAllRecordsMutex.Lock()
	defer fake.getAllRecordsMutex.Unlock()
	fake.GetAllRecordsStub = stub
}

func (fake *FakeRecordService) GetAllRecordsReturns(result1 *[]models.Record, result2 error) {
	fake.getAllRecordsMutex.Lock()
	defer fake.getAllRecordsMutex.Unlock()
	fake.GetAllRecordsStub = nil
	fake.getAllRecordsReturns = struct {
		result1 *[]models.Record
		result2 error
	}{result1, result2}
}

func (fake *FakeRecordService) GetAllRecordsReturnsOnCall(i int, result1 *[]models.Record, result2 error) {
	fake.getAllRecordsMutex.Lock()
	defer fake.getAllRecordsMutex.Unlock()
	fake.GetAllRecordsStub = nil
	if fake.getAllRecordsReturnsOnCall == nil {
		fake.getAllRecordsReturnsOnCall = make(map[int]struct {
			result1 *[]models.Record
			result2 error
		})
	}
	fake.getAllRecordsReturnsOnCall[i] = struct {
		result1 *[]models.Record
		result2 error
	}{result1, result2}
}

func (fake *FakeRecordService) GetRecord(arg1 string) (*models.Record, error) {
	fake.getRecordMutex.Lock()
	ret, specificReturn := fake.getRecordReturnsOnCall[len(fake.getRecordArgsForCall)]
	fake.getRecordArgsForCall = append(fake.getRecordArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetRecordStub
	fakeReturns := fake.getRecordReturns
	fake.recordInvocation("GetRecord", []interface{}{arg1})
	fake.getRecordMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRecordService) GetRecordCallCount() int {
	fake.getRecordMutex.RLock()
	defer fake.getRecordMutex.RUnlock()
	return len(fake.getRecordArgsForCall)
}

func (fake *FakeRecordService) GetRecordCalls(stub func(string) (*models.Record, error)) {
	fake.getRecordMutex.Lock()
	defer fake.getRecordMutex.Unlock()
	fake.GetRecordStub = stub
}

func (fake *FakeRecordService) GetRecordArgsForCall(i int) string {
	fake.getRecordMutex.RLock()
	defer fake.getRecordMutex.RUnlock()
	argsForCall := fake.getRecordArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRecordService) GetRecordReturns(result1 *models.Record, result2 error) {
	fake.getRecordMutex.Lock()
	defer fake.getRecordMutex.Unlock()
	fake.GetRecordStub = nil
	fake.getRecordReturns = struct {
		result1 *models.Record
		result2 error
	}{result1, result2}
}

func (fake *FakeRecordService) GetRecordReturnsOnCall(i int, result1 *models.Record, result2 error) {
	fake.getRecordMutex.Lock()
	defer fake.getRecordMutex.Unlock()
	fake.GetRecordStub = nil
	if fake.getRecordReturnsOnCall == nil {
		fake.getRecordReturnsOnCall = make(map[int]struct {
			result1 *models.Record
			result2 error
		})
	}
	fake.getRecordReturnsOnCall[i] = struct {
		result1 *models.Record
		result2 error
	}{result1, result2}
}

func (fake *FakeRecordService) GetRecordsByType(arg1 string) (*[]models.Record, error) {
	fake.getRecordsByTypeMutex.Lock()
	ret, specificReturn := fake.getRecordsByTypeReturnsOnCall[len(fake.getRecordsByTypeArgsForCall)]
	fake.getRecordsByTypeArgsForCall = append(fake.getRecordsByTypeArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetRecordsByTypeStub
	fakeReturns := fake.getRecordsByTypeReturns
	fake.recordInvocation("GetRecordsByType", []interface{}{arg1})
	fake.getRecordsByTypeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRecordService) GetRecordsByTypeCallCount() int {
	fake.getRecordsByTypeMutex.RLock()
	defer fake.getRecordsByTypeMutex.RUnlock()
	return len(fake.getRecordsByTypeArgsForCall)
}

func (fake *FakeRecordService) GetRecordsByTypeCalls(stub func(string) (*[]models.Record, error)) {
	fake.getRecordsByTypeMutex.Lock()
	defer fake.getRecordsByTypeMutex.Unlock()
	fake.GetRecordsByTypeStub = stub
}

func (fake *FakeRecordService) GetRecordsByTypeArgsForCall(i int) string {
	fake.getRecordsByTypeMutex.RLock()
	defer fake.getRecordsByTypeMutex.RUnlock()
	argsForCall := fake.getRecordsByTypeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRecordService) GetRecordsByTypeReturns(result1 *[]models.Record, result2 error) {
	fake.getRecordsByTypeMutex.Lock()
	defer fake.getRecordsByTypeMutex.Unlock()
	fake.GetRecordsByTypeStub = nil
	fake.getRecordsByTypeReturns = struct {
		result1 *[]models.Record
		result2 error
	}{result1, result2}
}

func (fake *FakeRecordService) GetRecordsByTypeReturnsOnCall(i int, result1 *[]models.Record, result2 error) {
	fake.getRecordsByTypeMutex.Lock()
	defer fake.getRecordsByTypeMutex.Unlock()
	fake.GetRecordsByTypeStub = nil
	if fake.getRecordsByTypeReturnsOnCall == nil {
		fake.getRecordsByTypeReturnsOnCall = make(map[int]struct {
			result1 *[]models.Record
			result2 error
		})
	}
	fake.getRecordsByTypeReturnsOnCall[i] = struct {
		result1 *[]models.Record
		result2 error
	}{result1, result2}
}

func (fake *FakeRecordService) UpdateRecord(arg1 *models.Record) error {
	fake.updateRecordMutex.Lock()
	ret, specificReturn := fake.updateRecordReturnsOnCall[len(fake.updateRecordArgsForCall)]
	fake.updateRecordArgsForCall = append(fake.updateRecordArgsForCall, struct {
		arg1 *models.Record
	}{arg1})
	stub := fake.UpdateRecordStub
	fakeReturns := fake.updateRecordReturns
	fake.recordInvocation("UpdateRecord", []interface{}{arg1})
	fake.updateRecordMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeRecordService) UpdateRecordCallCount() int {
	fake.updateRecordMutex.RLock()
	defer fake.updateRecordMutex.RUnlock()
	return len(fake.updateRecordArgsForCall)
}

func (fake *FakeRecordService) UpdateRecordCalls(stub func(*models.Record) error) {
	fake.updateRecordMutex.Lock()
	defer fake.updateRecordMutex.Unlock()
	fake.UpdateRecordStub = stub
}

func (fake *FakeRecordService) UpdateRecordArgsForCall(i int) *models.Record {
	fake.updateRecordMutex.RLock()
	defer fake.updateRecordMutex.RUnlock()
	argsForCall := fake.updateRecordArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRecordService) UpdateRecordReturns(result1 error) {
	fake.updateRecordMutex.Lock()
	defer fake.updateRecordMutex.Unlock()
	fake.UpdateRecordStub = nil
	fake.updateRecordReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRecordService) UpdateRecordReturnsOnCall(i int, result1 error) {
	fake.updateRecordMutex.Lock()
	defer fake.updateRecordMutex.Unlock()
	fake.UpdateRecordStub = nil
	if fake.updateRecordReturnsOnCall == nil {
		fake.updateRecordReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateRecordReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRecordService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createRecordMutex.RLock()
	defer fake.createRecordMutex.RUnlock()
	fake.deleteRecordMutex.RLock()
	defer fake.deleteRecordMutex.RUnlock()
	fake.getAllRecordsMutex.RLock()
	defer fake.getAllRecordsMutex.RUnlock()
	fake.getRecordMutex.RLock()
	defer fake.getRecordMutex.RUnlock()
	fake.getRecordsByTypeMutex.RLock()
	defer fake.getRecordsByTypeMutex.RUnlock()
	fake.updateRecordMutex.RLock()
	defer fake.updateRecordMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeRecordService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ balancer.RecordService = new(FakeRecordService)
